# Guide to Implementing BGC Parameter Map Visualization

This document explains the functionality of the `BGC_scatter_map_data_mode.ipynb` notebook and provides a step-by-step guide on how to integrate this feature into the existing Streamlit chatbot application.

## 1. What the `BGC_scatter_map_data_mode.ipynb` Notebook Does

The primary purpose of this notebook is to create a world map that shows the location of Argo floats measuring a specific **Biogeochemical (BGC)** parameter, and to color-code these locations based on the **data mode** (i.e., the quality) of the measurements.

Here are the steps it follows:

1.  **Loads BGC Data Index:** It starts by loading an index of all BGC Argo float profiles. This is different from the core Argo data and contains information about biogeochemical measurements like oxygen (`DOXY`), chlorophyll, nitrates, etc.
2.  **Selects a BGC Parameter:** It chooses a specific BGC parameter to investigate (e.g., `BBP700`, which is related to particle backscattering, or `DOXY` for dissolved oxygen).
3.  **Searches for Relevant Floats:** It searches the index to find all the float profiles that have measurements for the selected parameter.
4.  **Extracts Data Mode:** For each of these profiles, it extracts the "data mode" for the chosen parameter. The data mode is a single letter that tells you about the quality and processing level of the data:
    *   `R`: Real-time data (raw, uncalibrated).
    *   `A`: Adjusted data (calibrated, but not fully quality-controlled).
    *   `D`: Delayed-mode data (highest quality, fully calibrated and scientifically validated).
5.  **Generates a Scatter Map:** Finally, it uses `argopy`'s plotting function to generate a world map. Each point on the map is a float profile, and the color of the point corresponds to the data mode (`R`, `A`, or `D`), giving a visual overview of the global data quality for that specific BGC parameter.

## 2. How to Integrate This Functionality into the Project

Integrating this functionality into your Streamlit chatbot would be a fantastic way to add a powerful data visualization feature. Since your application is a conversational agent, the best approach is to create a new tool that the agent can use when a user asks for this kind of visualization.

Hereâ€™s a detailed guide on how to implement it:

### Step 1: Create a New Tool in `app.py`

You should define a new function in `app.py` and decorate it with `@tool`. This function will encapsulate the logic from the notebook.

```python
# In app.py, add this new tool function

from pydantic import BaseModel, Field

class BGCParameter(BaseModel):
    parameter: str = Field(description="The BGC parameter to visualize (e.g., 'DOXY', 'BBP700').")

@tool(args_schema=BGCParameter)
def generate_bgc_parameter_map(parameter: str):
    """Generates a world map showing the data quality for a given BGC parameter."""
    try:
        from argopy import ArgoIndex
        from argopy.plot import scatter_map
        import matplotlib.pyplot as plt

        # Load the BGC index
        idx = ArgoIndex(index_file='bgc-b').load()

        # Search for the parameter
        idx.search_params(parameter)
        if idx.N_MATCH == 0:
            return f"No data found for the BGC parameter: {parameter}"

        # Convert to DataFrame and extract data mode
        df = idx.to_dataframe()
        df["variables"] = df["parameters"].apply(lambda x: x.split())
        df[f"{parameter}_DM"] = df.apply(lambda x: x['parameter_data_mode'][x['variables'].index(parameter)] if parameter in x['variables'] else '', axis=1)

        # Generate the map
        fig, ax = scatter_map(df,
                                hue=f"{parameter}_DM",
                                cmap="data_mode",
                                figsize=(10, 6),
                                markersize=5)
        ax.set_title(f"Global Data Mode for BGC Parameter: {parameter}")

        # Save the map to a file
        image_path = "bgc_map.png"
        plt.savefig(image_path)
        plt.close(fig) # Close the figure to free up memory

        return f"Map generated and saved to {image_path}"
    except Exception as e:
        return f"Error generating map: {e}"

```

### Step 2: Add the New Tool to the Agent

In `app.py`, you need to add the newly created tool to the list of tools that the agent can use.

```python
# In app.py, modify the 'tools' list

tools = [fetch_argo_data_by_region, generate_bgc_parameter_map]
```

### Step 3: Update the Agent's Prompt

To make the agent aware of its new capability, you should update the custom prompt template to include a description of the new tool.

```python
# In app.py, you can add more details to the prompt if needed,
# but the agent should be able to infer the tool's purpose from its name and docstring.
# The current prompt is already quite good at encouraging the agent to use the tools it has.
```

### Step 4: Handle Image Display in the Streamlit Frontend

The final step is to modify the Streamlit part of `app.py` to display the map image when the tool returns its path.

```python
# In app.py, update the Streamlit section that handles the agent's response

    # Get assistant response by invoking the agent
    with st.chat_message("assistant"):
        with st.spinner("Thinking..."):
            # Invoke the agent with the user's prompt
            response = agent_executor.invoke({"input": prompt})
            response_text = response.get("output", "I encountered an error.")

            # Check if the response contains a path to a generated map
            if "Map generated and saved to" in response_text:
                image_path = response_text.split("Map generated and saved to")[-1].strip()
                st.markdown("Here is the map you requested:")
                st.image(image_path)
            else:
                st.markdown(response_text)
    
    # Add assistant response to history
    st.session_state.messages.append({"role": "assistant", "content": response_text})

```

### How It All Fits Together

With these changes, the workflow would be:

1.  **User:** "Show me a map of the data quality for DOXY."
2.  **Agent:** The agent understands the request and sees that the `generate_bgc_parameter_map` tool is the best fit.
3.  **Agent:** It calls the tool with `parameter="DOXY"`.
4.  **Tool:** The tool runs the code from the notebook, generates a map, saves it as `bgc_map.png`, and returns the message "Map generated and saved to bgc_map.png".
5.  **Frontend:** The Streamlit code receives this message, extracts the image path, and displays the image to the user using `st.image()`.

This creates a seamless and powerful new feature for your application, moving it from a purely text-based assistant to one that can provide rich data visualizations.
